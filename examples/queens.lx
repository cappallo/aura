module examples.queens

type SearchResult {
  count: Int
  text: String
}

fn solve_queens(n: Int) -> SearchResult {
  search_queens(n, 0, [])
}

fn solve_eight_queens() -> SearchResult {
  solve_queens(8)
}

fn search_queens(size: Int, row: Int, positions: List<Int>) -> SearchResult {
  if row == size {
    return SearchResult { count: 1, text: render_board(positions) }
  } else {
    return explore_columns(size, row, 0, positions)
  }
}

fn explore_columns(size: Int, row: Int, column: Int, positions: List<Int>) -> SearchResult {
  if column >= size {
    return SearchResult { count: 0, text: "" }
  } else {
    let current = if is_safe(positions, row, column) {
      let next_positions = append_position(positions, column)
      search_queens(size, row + 1, next_positions)
    } else {
      SearchResult { count: 0, text: "" }
    }
    let rest = explore_columns(size, row, column + 1, positions)
    return combine_results(current, rest)
  }
}

fn combine_results(left: SearchResult, right: SearchResult) -> SearchResult {
  let combined_count = left.count + right.count
  let combined_text = str.concat(left.text, right.text)
  SearchResult { count: combined_count, text: combined_text }
}

fn is_safe(positions: List<Int>, row: Int, column: Int) -> Bool {
  return check_conflicts(positions, row, column, 0)
}

fn check_conflicts(positions: List<Int>, row: Int, column: Int, index: Int) -> Bool {
  if index >= row {
    return true
  } else {
    let placed_column = positions[index]
    if placed_column == column {
      return false
    } else {
      let row_diff = row - index
      let col_diff_raw = column - placed_column
      let col_diff = abs_value(col_diff_raw)
      if col_diff == row_diff {
        return false
      } else {
        return check_conflicts(positions, row, column, index + 1)
      }
    }
  }
}

fn abs_value(value: Int) -> Int {
  if value < 0 {
    return -value
  } else {
    return value
  }
}

fn append_position(positions: List<Int>, value: Int) -> List<Int> {
  let length = list.len(positions)
  return build_list_with_append(positions, value, 0, length)
}

fn build_list_with_append(positions: List<Int>, value: Int, index: Int, length: Int) -> List<Int> {
  if index >= length {
    return [value]
  } else {
    let current = positions[index]
    let rest = build_list_with_append(positions, value, index + 1, length)
    return prepend_to_list(current, rest)
  }
}

fn prepend_to_list(item: Int, rest: List<Int>) -> List<Int> {
  let rest_length = list.len(rest)
  return build_list_with_prepend(item, rest, 0, rest_length)
}

fn build_list_with_prepend(item: Int, rest: List<Int>, index: Int, length: Int) -> List<Int> {
  if index == 0 {
    if length == 0 {
      return [item]
    } else {
      if length == 1 {
        return [item, rest[0]]
      } else {
        if length == 2 {
          return [item, rest[0], rest[1]]
        } else {
          if length == 3 {
            return [item, rest[0], rest[1], rest[2]]
          } else {
            if length == 4 {
              return [item, rest[0], rest[1], rest[2], rest[3]]
            } else {
              if length == 5 {
                return [item, rest[0], rest[1], rest[2], rest[3], rest[4]]
              } else {
                if length == 6 {
                  return [item, rest[0], rest[1], rest[2], rest[3], rest[4], rest[5]]
                } else {
                  if length == 7 {
                    return [item, rest[0], rest[1], rest[2], rest[3], rest[4], rest[5], rest[6]]
                  } else {
                    if length == 8 {
                      return [item, rest[0], rest[1], rest[2], rest[3], rest[4], rest[5], rest[6], rest[7]]
                    } else {
                      if length == 9 {
                        return [item, rest[0], rest[1], rest[2], rest[3], rest[4], rest[5], rest[6], rest[7], rest[8]]
                      } else {
                        if length == 10 {
                          return [item, rest[0], rest[1], rest[2], rest[3], rest[4], rest[5], rest[6], rest[7], rest[8], rest[9]]
                        } else {
                          return [item]
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } else {
    return [item]
  }
}

fn render_board(positions: List<Int>) -> String {
  let size = list.len(positions)
  let rows = render_rows(positions, 0, size)
  return str.concat(rows, "\n")
}

fn render_rows(positions: List<Int>, row: Int, size: Int) -> String {
  if row >= size {
    return ""
  } else {
    let row_text = render_row(positions, row, 0, size)
    let with_newline = str.concat(row_text, "\n")
    let rest = render_rows(positions, row + 1, size)
    return str.concat(with_newline, rest)
  }
}

fn render_row(positions: List<Int>, row: Int, column: Int, size: Int) -> String {
  if column >= size {
    return ""
  } else {
    let queen_column = positions[row]
    let cell = if column == queen_column {
      "Q"
    } else {
      "."
    }
    let tail = render_row(positions, row, column + 1, size)
    return str.concat(cell, tail)
  }
}

fn print_solutions(n: Int) -> String {
  let result = solve_queens(n)
  return result.text
}

fn print_eight_queens() -> String {
  return print_solutions(8)
}

test eight_queens_count {
  let result = solve_eight_queens()
  test.assert_equal(result.count, 92)
}

test eight_queens_first_board {
  let result = solve_eight_queens()
  test.assert_equal(str.slice(result.text, 0, 8), "Q.......")
  test.assert_equal(str.slice(result.text, 9, 17), "....Q...")
}
